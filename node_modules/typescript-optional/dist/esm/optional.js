export class Optional {
    isEmpty() {
        return !this.isPresent();
    }
    static of(value) {
        if (value !== null && value !== undefined)
            return new PresentOptional(value);
        else
            throw new TypeError("The passed value was null or undefined.");
    }
    static ofNonNull(value) {
        return Optional.of(value);
    }
    static ofNullable(nullable) {
        if (nullable !== null && nullable !== undefined)
            return new PresentOptional(nullable);
        else
            return new EmptyOptional();
    }
    static empty() {
        return new EmptyOptional();
    }
    static from(option) {
        switch (option.kind) {
            case "present": return Optional.of(option.value);
            case "empty": return Optional.empty();
            default: throw new TypeError("The passed value was not an Option type.");
        }
    }
}
export class PresentOptional extends Optional {
    constructor(value) {
        super();
        this.payload = value;
    }
    isPresent() {
        return true;
    }
    get() {
        return this.payload;
    }
    ifPresent(consumer) {
        consumer(this.payload);
    }
    ifPresentOrElse(consumer, emptyAction) {
        consumer(this.payload);
    }
    filter(predicate) {
        return (predicate(this.payload)) ? this : Optional.empty();
    }
    map(mapper) {
        const result = mapper(this.payload);
        return Optional.ofNullable(result);
    }
    flatMap(mapper) {
        return mapper(this.payload);
    }
    or(supplier) {
        return this;
    }
    orElse(another) {
        return this.payload;
    }
    orElseGet(another) {
        return this.payload;
    }
    orElseThrow(exception) {
        return this.payload;
    }
    orNull() {
        return this.payload;
    }
    orUndefined() {
        return this.payload;
    }
    toOption() {
        return { kind: "present", value: this.payload };
    }
    matches(cases) {
        return cases.present(this.payload);
    }
    toJSON(key) {
        return this.payload;
    }
}
export class EmptyOptional extends Optional {
    isPresent() {
        return false;
    }
    constructor() {
        super();
    }
    get() {
        throw new TypeError("The optional is not present.");
    }
    ifPresent(consumer) {
    }
    ifPresentOrElse(consumer, emptyAction) {
        emptyAction();
    }
    filter(predicate) {
        return this;
    }
    map(mapper) {
        return Optional.empty();
    }
    flatMap(mapper) {
        return Optional.empty();
    }
    or(supplier) {
        return supplier();
    }
    orElse(another) {
        return another;
    }
    orElseGet(another) {
        return this.orElse(another());
    }
    orElseThrow(exception) {
        throw exception();
    }
    orNull() {
        return null;
    }
    orUndefined() {
        return undefined;
    }
    toOption() {
        return { kind: "empty" };
    }
    matches(cases) {
        return cases.empty();
    }
    toJSON(key) {
        return null;
    }
}
//# sourceMappingURL=optional.js.map