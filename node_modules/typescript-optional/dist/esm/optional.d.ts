import { Cases, Option } from "./types.js";
export declare abstract class Optional<T> {
    abstract isPresent(): boolean;
    isEmpty(): boolean;
    abstract get(): T;
    abstract ifPresent(consumer: (value: T) => void): void;
    abstract ifPresentOrElse(consumer: (value: T) => void, emptyAction: () => void): void;
    abstract filter(predicate: (value: T) => boolean): Optional<T>;
    abstract map<U>(mapper: (value: T) => U): Optional<NonNullable<U>>;
    abstract flatMap<U>(mapper: (value: T) => Optional<U>): Optional<U>;
    abstract or(supplier: () => Optional<T>): Optional<T>;
    abstract orElse(another: T): T;
    abstract orElseGet(supplier: () => T): T;
    abstract orElseThrow<U>(errorSupplier: () => U): T;
    abstract orNull(): T | null;
    abstract orUndefined(): T | undefined;
    abstract toOption(): Option<T>;
    abstract matches<U>(cases: Cases<T, U>): U;
    abstract toJSON(key: string): unknown;
    static of<T>(value: T): Optional<T>;
    static ofNonNull<T>(value: T): Optional<T>;
    static ofNullable<T>(nullable: T | null | undefined): Optional<T>;
    static empty<T>(): Optional<T>;
    static from<T>(option: Option<T>): Optional<T>;
}
export declare class PresentOptional<T> extends Optional<T> {
    payload: T;
    isPresent(): boolean;
    constructor(value: T);
    get(): T;
    ifPresent(consumer: (value: T) => void): void;
    ifPresentOrElse(consumer: (value: T) => void, emptyAction: () => void): void;
    filter(predicate: (value: T) => boolean): Optional<T>;
    map<U>(mapper: (value: T) => U): Optional<NonNullable<U>>;
    flatMap<U>(mapper: (value: T) => Optional<U>): Optional<U>;
    or(supplier: () => Optional<T>): Optional<T>;
    orElse(another: T): T;
    orElseGet(another: () => T): T;
    orElseThrow<U>(exception: () => U): T;
    orNull(): T;
    orUndefined(): T;
    toOption(): Option<T>;
    matches<U>(cases: Cases<T, U>): U;
    toJSON(key: string): unknown;
}
export declare class EmptyOptional<T> extends Optional<T> {
    isPresent(): boolean;
    constructor();
    get(): T;
    ifPresent(consumer: (value: T) => void): void;
    ifPresentOrElse(consumer: (value: T) => void, emptyAction: () => void): void;
    filter(predicate: (value: T) => boolean): Optional<T>;
    map<U>(mapper: (value: T) => U): Optional<NonNullable<U>>;
    flatMap<U>(mapper: (value: T) => Optional<U>): Optional<U>;
    or(supplier: () => Optional<T>): Optional<T>;
    orElse(another: T): T;
    orElseGet(another: () => T): T;
    orElseThrow<U>(exception: () => U): T;
    orNull(): null;
    orUndefined(): undefined;
    toOption(): Option<T>;
    matches<U>(cases: Cases<T, U>): U;
    toJSON(key: string): unknown;
}
